/*
	Оглавление

	ПЕРЕМЕННЫЕ
	ТИПЫ ДАННЫХ

	АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ
	ОПЕРАТОР ПРИСВАИВАНИЯ
	ОПЕРАТОРЫ СРАВНЕНИЯ
	ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
	ТЕРНАРНЫЙ ОПЕРАТОР
	СТРОКОВЫЕ ОПЕРАТОРЫ

	if
	else
	else if
	switch
	for
	while
	do while
	break
	continue

	ФУНКЦИИ / return

	Окно alert / Окно prompt / Окно confirm

	ОБЪЕКТЫ / Math / Date

	МЕТОДЫ / setInterval

	МАССИВЫ

	DOM
	Добавление элементов / Удаление элементов / Замена элементов / Анимация
	СОБЫТИЯ

	ES6
	Переменные
	Шаблонные строки
	Цикл for...in / Цикл for...of
	Функции в ES6
	Объекты в ES6 / Object.assign()
	Деструктуризация
	rest - параметры
	Оператор расширения
	КЛАССЫ / Методы класса / Наследование в классах
	Map
	Set
*/




// ПЕРЕМЕННЫЕ

	var x = 10;

/*
Ключевое слово "var" используется для объявления переменной

Оператор присвоения "=" объявляет значение переменной. Переменная может быть объявлена без значения (будет иметь неопределённое значение), и ее значение может быть предоставлено позже, например, пользовательский ввод.

Правила наименования:
- в JavaScript имя переменной чувствительно к регистру! (myName и myname - разные переменные).
- первым символом может быть только буква, или "_", или "$".
- числа не могут использоваться первым символом в имени переменной.
- в имени переменной нельзя использовать математические и логические операторы, спецсимволы (#, % и т.п.) и пробелы.
- не использовать зарезервированные в JavaScript слова.
*/

// ТИПЫ ДАННЫХ
/*
Переменные в JS могут хранить много типов данных, напр. числа, строки, массивы, и др.

В отличие от других языков, JS не определяет различные числовые типы на целочисленные, с плав. точкой и проч.
Числа в JS всегда хранятся, как числа с плавающей точкой двойной точности (55.01).

Переменная может быть легко изменена на другой тип с помощью присвоения ей любого другого значения типа данных.

Числа в кавычках истолковываются как строки: "42" это не число 42, это строка с двумя символами, 4 и 2.
*/

	var x1 = 42;
	var x1 = 'какая-нибудь строка';
	var x1 = "строка в двойных кавычках";
	var x1 = "строка с 'одинарными кавычками' в двойных кавычках";
	var x1 = "строка с \"двойными кавычками\" в двойных кавычках";
	var x1 = 'строка с "двойными кавычками" в одинарных кавычках';
	var x1 = 'строка с \'одинарными кавычками\' в одинарных кавычках';
	var x1 = true; // булевое значение Истина
	var x1 = false; // булевое значение Ложь

/*
0 (null) - имеет неопределённое значение.
Пустая строка - имеет булевое значение false.
Заполненное значение - true.

Управляющий символ (\) может быть использован для вставки спецсимволов в строку:
Код		Вывод
\'		одинарная кавычками
\"		двойные кавычки
\\		обратный слэш
\n		новая строка
\r		возврат каретки
\t		табуляция
\b		бэкспейс
\f		прогон страницы
*/

// АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ
/*
+	сложение
-	вычитание
*	умножение
/	деление
%	деление по модулю (пример: 56 % 3 = 2). В JS деление по модулю может использоваться и для чисел с плавающей точкой.
++	инкремент (var a = 10; a++; теперь a=11)
--	декремент (var a = 10; a--; теперь a=9)

Можно получить результат строкового выражения, используя функцию eval(), которая принимает аргумент строкового выражения, например, eval("10 * 20 + 8"), и возвращает результат. Если аргумент пуст, он возвращает результат неопределённым.
*/

// ОПЕРАТОР ПРИСВАИВАНИЯ
/*
Оператор	Пример		Эквивалентен
=			x = y		x = y
+=			x += y		x = x + y
-=			x -= y		x = x - y
*=			x *= y		x = x * y
/=			x /= y		x = x / y
%=			x %= y		x = x % y

Можно использовать несколько операторов присвоения в одной строке, например x -= y += 9.
*/

// ОПЕРАТОРЫ СРАВНЕНИЯ
/*
Оператор	Описание
==			равно
===			идентично (равно и одинакового типа)
!=			не равно
!==			не идентично
>			больше чем
>=			больше или равно
<			меньше чем
<=			меньше или равно

Сравнивать нужно аргументы одинакового типа, - числа с числами, строки со строками и т.д.
*/

// ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
/*
Оператор	Описание
&&			И - true если обе операнды истинны
||			ИЛИ - true если один из операндов истинный
!			НЕ - true если операнд ложный, false если операнд истинный
*/

// ТЕРНАРНЫЙ ОПЕРАТОР
/*
Оператор	Описание
?			Условный (Тернарный) оператор присваивает значение переменной, основываясь на некотором условии.

Синтаксис: переменная = (условие) ? значениеЕслиИстина: значениеЕслиЛожь;
*/
	var isAdult = (age < 18) ? "Несовершеннолетний": "Совершеннолетний";

// СТРОКОВЫЕ ОПЕРАТОРЫ
/*
Конкатенация (+) используется для построения строк путем соединения множества других строк или путем соединения строк с другими типами.
*/
	var mystring1 = "Из песни ";
	var mystring2 = "слов не выкинешь!";
	document.write(mystring1 + mystring2);



// ОПЕРАТОР if
/*
if (условие) {
	блок кода, исполняемый, если условие будет истинно
}
*/
	var myNum1 = 7;
	var myNum2 = 10;
	if (myNum1 < myNum2) {
		alert("Ты прав!");
	}

// ОПЕРАТОР else
/* 
Используется для указания блока кода, который должен выполняться, если условие ложно.
*/
	var myNum1 = 7;
	var myNum2 = 10;
	if (myNum1 < myNum2) {
		alert("Ты прав!");
	} else {
		alert("Отнюдь!");
	}

// ОПЕРАТОР else if
/*
Используется для указания нового условия, если первое условие ложно.
Операторов else if может быть сколько угодно.
После else if обязательно должен быть оператор else!
*/
	var myNum1 = 7;
	var myNum2 = 10;
	if (myNum1 < myNum2) {
		alert("Ты прав!");
	} else if (myNum1 == myNum2) {
		alert("Договоримся!");
	} else {
		alert("Не фига!");
	}

// ОПЕРАТОР switch
/* Более элегантный аналог else if. */
	var day = 2;
	switch (day) {
		case 1:
			document.write("Понедельник");
			break; // выход из блока switch
		case 2:
			document.write("Вторник");
			break;
		case 3:
			document.write("Среда");
			break;
		default: // действие по умолчанию, если не было получено соответствие. Может быть опущено.
			document.write("Другой день");
	}



// ЦИКЛ for
/*
Синтаксис:
for (выражение1; выражение2; выражение3) {
	исполняемый код
}

Выражение1 выполняется до запуска цикла.
Выражение2 определяет условие для запуска цикла.
Выражение3 выполняется каждый раз после выполнения цикла.
*/
	for (i=1; i<=5; i++) {
		document.write(i + "<br />");
	}

/* Выражение1 - опциональное, и может быть опущено, если значения заданы до запуска цикла. */
	var a = 1;
	for (; a<=5; a++) {
		document.write(a + "<br />");
	}

/* Можно использовать несколько значений в выражении1, разделяя их запятыми. */
	for (b=1, text=""; b<=5; b++) {
		text = b;
		document.write(b + "<br />");
	}

/*
Выражение2 можно опустить, заменив его выходом (break) внутри самого цикла, иначе он будет бесконечным.
Выражение3 тоже опциональное и может быть опущено, если производить необходимые изменения значения внутри самого цикла.
*/
	var c = 1;
	for (; c<10; ) {
		document.write(c);
		c++;
	}
/* Допускается использование нескольких вложенных циклов. */

// ЦИКЛ while
/* Повторяет блок кода, пока определенное условие является истинным. 
Синтаксис:
while (условие) {
	исполняемый код
}
*/
	var d=0;
	while (d<10) {
		document.write(d);
		d++;
	}

// ЦИКЛ do while
/* Является вариацией цикла while. 
Синтаксис:
do {
	исполняемый код
}
while (условие);
*/
	var e=20;
	do {
		document.write(e);
		e++;
	}
	while (e<=25);

// break
/* Выводит из цикла и продолжает выполнение кода после цикла. */
	for (f = 0; f <= 10; f++) {
		if (f == 5) {
			break;
		}
		document.write(f);
	}

// continue
/* Останавливает только одну текущую итерацию, и продолжает со следующей итерации. */
	for (g = 0; g <= 10; g++) {
		if (g == 5) {
			continue;
		}
		document.write(g); // будут выведены числа от 0 до 10, кроме 5.
	}



// ФУНКЦИИ
/*
Для определения функции в JS используется ключевое слово function, за которым следует ее имя и пара круглых скобок.
Исполняемый функцией код пишется в фигурных скобках.
Синтаксис:
function name() {
	исполняемый код
}

Правила именования функций - как и у переменных.

Для вызова функции пишем ее имя и добавляем в скобки аргументы.
*/
	function sayHello(name) {
		alert("Привет, " + name);
	}
	
	sayHello("Эдик"); // выведет "Привет, Эдик"
	sayHello("Антон"); // выведет "Привет, Антон"
	sayHello("Глюк"); // выведет "Привет, Глюк"

/*
Можно определить множество параметров для функции, разделяя их запятыми:
function myFun(x, y) {
	some code
}
*/

/*
Опциональная инструкция return возвращает значение (например, для выполнения вычисления и получения результата)
*/
	function myFunction(a, b) {
		return a * b;
	}
	var x = myFunction(5, 6); // x равен 30
	
	function addNumbers(a, b) {
		var c = a+b;
		return c;
	}
	document.write( addNumbers(40, 2) ); // выведет 42



// ВСПЛЫВАЮЩЕЕ ОКНО alert
/*
alert - окно предупреждения, чтобы убедиться, что пользователь получил информацию. Пользователь должен нажать ОК, чтобы продолжить.
*/
	alert("Вы пользуетесь данным контентом на свой страх и риск!");

	alert("Привет!\nРад снова тебя здесь видеть."); // с переводом строки

// ВСПЛЫВАЮЩЕЕ ОКНО prompt
/*
prompt инпользуется для пользовательского ввода. Имеет два параметра: первый - текст, который необходимо отобразить в окне, второй (опционально) текст по умолчанию, отображаемый в поле для ввода. Отмена возвращает null.
*/
	var x = prompt("Ваше имя", "Антон");
	if(x == null) {
		document.write("Без имени");
	} else {
		document.write(x);
	}

// ВСПЛЫВАЮЩЕЕ ОКНО confirm
/*
confirm используется для подтверждения или проверки пользователем чего-либо. Нажатие на ОК вернет true, на ОТМЕНУ - вернет false.
*/
	var x = confirm("Хотите покинуть сайт?");
	if(x == true) {
		document.write("Скатертью дорога!");
	} else {
		document.write("Правильно, оставайтесь. У нас есть печеньки!");
	}



// ОБЪЕКТЫ
/*
Объекты в js это переменные, которые могут хранить много значений (свойств), записанных как пара имя:значение.
*/
	var person = {
		name: "John", age: 31, favColor: "green", height: 183
	};
/* или так, пробелы и разрывы строк не важны: */
	var person = {
		name: "John",
		age: 31,
		favColor: "green",
		height: 183
	};
/*
Свойство (метод)	Значение Свойства
	name				John
	age					31
	favColor			green
	height				183
*/
	var x = person.age;		// вариант 1 получения доступа к свойству объекта
	var y = person['age'];	// вариант 2 получения доступа к свойству объекта
/* встроенное свойство js length используется для подсчёта числа символов в свойстве или в строке. */
	document.write(person.name.length); // 4

/*
Для создания множества однотипных объектов используется функция конструктора объекта. Она принимает параметры и присваивает их свойствам объекта.
*/
	function person(name, age, color) {
		this.name = name;
		this.age = age;
		this.favColor = color;
	}
/* Для создания новых объектов одинакового типа на основе конструктора, используется ключевое слово new. */
	var p1 = new person("John", 42, "green");
	var p2 = new person("Amy", 21, "red");
	document.write(p1.color); // green
	document.write(p2.age); // 21



// Объект Math (позволяет выполнять матем. действия и включает некоторые свойства)
	document.write(Math.PI); // 3.141592653589793
/*
Некоторые методы объекта Math:
Метод				Описание
cos(x)				возвращает косинус числа x в радианах
sin(x)				возвращает синус числа x в радианах
tan(x)				возвращает тангенс числа x в радианах
acos(x)				возвращает арккосинус числа x в радианах
asin(x)				возвращает арксинус числа x в радианах
atan(x)				возвращает арктангенс числа x в радианах
ceil(x)				возвращает число, округлённое до целого в большую сторону
floor(x)			возвращает число, округлённое до целого в меньшую сторону
round(x)			возвращает число, округлённое до целого по матем.правилам
trunc(x)			(*) возвращает целую часть числа путём удаления всех дробных знаков
sign(x)				(*) возвращает знак числа, указывающий, является ли число положительным, отрицательным или нулём
max(x,y,z,...,n)	возвращает наибольшее из чисел
min(x,y,z,...,n)	возвращает наименьшее из чисел
pow(x,y)			возвращает значение числа x возведенного в степень y
sqrt(x)				возвращает квадратный корень числа x
random()			возвращает псевдослучайное число от 0 до 1

(*)	- новое API, работает только в новых браузерах, в IE - нет.

тригонометрические функции (sin(), cos(), tan(), asin(), acos(), atan() и atan2()) принимают в параметрах или возвращают углы в радианах. Для преобразования радианов в градусы, поделите их на величину (Math.PI / 180); для преобразования в обратном направлении, умножьте градусы на эту же величину.
*/
	document.write(Math.sqrt(4)); // получаем 2 - квадратный корень из 4



// Объект Date (состоит из года, месяца, дня, часа, минуты, секунды и милисекунды)
/* Даты в JS высчитываются в милисекундах (в сутках 86400000 мс) от 1 января 1970 */
	var d1 = new Date(); // текущая дата-время
	var d2 = new Date(76,10,11,19); // мой д/р - год, месяц (0 - январь), день, время
/*
Методы объекта Date:
Метод				Описание
getFullYear()		получает года
getMonth()			получает месяц
getDate()			получает день месяца
getDay()			получает день недели
getHours()			получает часа
getMinutes()		получает минуты
getSeconds()		получает секунды
getMilliseconds()	получает милисекунды
*/



// МЕТОДЫ
/* 
Методы - функции, которые хранятся как свойства.
Синтаксис: methodName = function() { code }
Для получения доступа к методу объекта: objectName.methodName()
*/
	function person(name, born) {
		this.name = name;
		this.born = born;
		this.year = function (year) {
			this.age = year - born;
		}
	}
	var p = new person("Виталий", 1976);
	p.year(2050); // доступ к методу объекта
	document.write(p.age); // покажет возраст в указанном году
/*
Другой вариант определить функцию вне конструктора и связать ее с объектом.
При этом вызываем метод с помощью имени свойства, указанного в конструкторе, а не с помощью имени функции.
*/
	function person(name, born) {
		this.name = name;
		this.born = born;
		this.year = oldYear;
	}
	function oldYear() {
		return y - this.born;
	}
	var p = new person("Виталий", 1976);
	var y = 2050;
	document.write(p.year()); // 74



// Метод setInterval (вызывает функцию на указанных интервалах (в милисекундах))
/* Продолжает вызывать функцию, пока не будет вызван clearInterval или не будет закрыто окно */
	function qwerty() {
		document.body.innerHTML = Math.ceil(Math.random()*100);
	}
	setInterval(qwerty, 1000); // будет выводить случайное число от 1 до 100 каждую секунду



// МАССИВЫ
/* Индексы массивов в JS - только порядковые цифровые и начинаются с 0 (0 - индекс первого элемента массива) */

// первый способ создания массива:
	var courses = new Array("HTML", "CSS", "JS", "C++");

// второй (рекомендованый) способ создания массива, используя литерал массива:
	var courses = ["HTML", "CSS", "JS", "C++"];

//третий способ создания массива - объявить массив, а сами элементы добавить позже:
	var courses = new Array();	// объявляем массив
	courses[0] = "HTML";		//
	courses[1] = "CSS";			// добавляем
	courses[2] = "JS";			// элементы
	courses[3] = "C++";			//

	var course = courses[0]; 		// HTML - получили доступ к первому элементу
	courses[1] = "Perl"; 			// поменяли второй элемент с CSS на Perl
	document.write(courses.length); // 4 - встроенное свойство массива length возвращает число его элементов
	
	var c1 = ["HTML", "CSS"];
	var c2 = ["JS", "C++"];
	var courses = c1.concat(c2); // метод concat объединяет массивы в новый массив



// DOM



	document.body.innerHTML = "Loren ipsum";
/*
Предопределенный объект document используется в JS для доступа ко всем элементам DOM, это владелец (root) всех объектов web-страницы. body - элемент объектной модели DOM, к которому мы получаем доступ и изменяем его содержание с помощью свойства innerHTML.

Свойство innerHTML может использоваться для изменения содержания всех элементов HTML.

	*************************************************************
	*	Часто используемые методы для выборки HTML элементов:	*
	*															*
	*	document.getElementById(id);							*
	*	document.getElementsByClassName(name);					*
	*	document.getElementsByTagName(name);					*
	*************************************************************
*/
	var x = document.getElementById("demo");	// находим нужный элемент
	x.innerHTML = "Привет мир!";				// модифицируем
/*
Метод getElementsByTagName() находит все элементы по имени тега и возвращает их в виде массива.
Метод getElementsByClassName() находит все элементы по имени класса и возвращает их в виде массива.
*/
// Пример:
	<p>hi</p>
	<p>hello</p>
	<p>hi</p>
	<script>
	var arr = document.getElementsByTagName("p");
	for (var x = 0; x < arr.length; x++) {
		arr[x].innerHTML = "Hi there";
	}
	</script>
// Стало:
	<p>Hi there</p>
	<p>Hi there</p>
	<p>Hi there</p>
/*
Каждый элемент DOM имеет набор свойств и методов, которые представляют информацию об их отношении в DOM:
element.childNodes		возвращает дочерние узлы элемента
element.firstChild		возвращает первый дочерний узел элемента
element.lastChild		возвращает последний дочерний узел элемента
element.hasChildNodes	возвр. true, если у элемента есть дочерний узел, иначе false
element.nextSibling		возвр. следующий элемент на одном уровне дерева
element.previousSibling	возвр. предыдущий узел на одном уровне дерева
element.parentNode		возвр. родительский узел элемента

JS может устанавливать и модифицировать и все свойства CSS. В именах свойств нельзя использовать дефис (-), их нужно заменять на "верблюжийРегистр".
*/
	var s = document.getElementsByTagName("span");
	for(var x=0; x<s.length; x++) {
		s[x].style.backgroundColor = "#33EA73";
	}
/*

// Добавление элементов:
/*
Для создания новых узлов используются следующие методы:
element.cloneNode()				возвращает дубликат узла из которого этот элемент был вызван
document.createElement(element)	создает новый узел элемента
document.createTextNode(text)	создает новый текстовый узел
*/
	var node = document.createTextNode("Lorem ipsum"); /* Будет создан новый текстовый узел, но появится он в документе только добавлением его к существующему элементу одним из методов: */
/*
element.appendChild(newNode)		добавляет новый дочерний узел к элементу в виде последнего дочернего узла
element.insertBefore(node1, node2)	вставляет node1 как дочерний до node2
*/

// Удаление элементов:
/* Для удаления элемента нужно выбрать родителя и использовать метод removeChild(node) */
	<div id="demo">
		<p id="p1">Lorem ipsum 1</p>
		<p id="p2">Lorem ipsum 2</p>
	</div>
	<script>
		var parent = document.getElementById("demo");
		var child = document.getElementById("p1");
		parent.removeChild(child);
	</script>
/* Другой способ удаления элемента - использование свойства parentNode для получения родителя элемента, который хотим удалить */
	var child = document.getElementById("p1");
	child.parentNode.removeChild(child);

// Замена элементов:
/* Для замены элементов исп. метод element.replaceChild(newNode, oldNode) */
	<div id="demo">
		<p id="p1">Lorem ipsum 1</p>
		<p id="p2">Lorem ipsum 2</p>
	</div>
	<script>
		var p = document.createElement("p"); // создаём новый параграф
		var node = document.createTextNode("Lorem ipsum 3"); // пишем текст
		p.appendChild(node); // вкладываем новый текст в новый параграф
		var parent = document.getElementById("demo"); // находим родителя, детей которого будем заменять
		var child = document.getElementById("p1"); // находим, что нужно заменить
		parent.replaceChild(p, child); // производим замену
	</script>

// Анимация
/* Процесс анимации использует принципы изменения элементов */
<style>
#container {
	width: 300px;
	height: 50px;
	background: green;
	position: relative;
}
#box {
	width: 10px;
	height: 50px;
	background: red;
	position: absolute;
}
</style>
<div id="container">
	<div id="box"></div>
</div>
<script>
	window.onload = function() {
		var box = document.getElementById('box');	// выбираем подопытного
		var pos = 0;								// устанавливаем счетчик для координаты перемещения
		var t = setInterval(move, 10);				// устанавливаем интервал перемещения, - функцию и скорость в мс
		
		function move() {							// функция перемещения
			if(pos >= 290) {						// условие переместить до конца (размер контейнера - размер перемещаемого блока)
				clearInterval(t);					// остановка по достижении условия
			} else {
				pos += 1;							// инкременируем счерчик координат
				box.style.left = pos+'px';			// переписываем HTML
			}
		}
	};
</script>

// СОБЫТИЯ
/* Соответствующие события могут быть добавлены в элемены HTML в качестве атрибутов: */
<p onclick="someFunc()">Loren ipsum</p>

/*
Событие			Описание
onclick			возникает при щелчке левой кнопки мыши на элементе
onload			возникает при загрузке объекта
onunload		срабатывает в том случае, когда страница по каким-либо причинам не загрузилась, либо при закрытии окна (вкладки)
onchange		возникает при изменении значения элемента формы (input, keygen, select, textarea)
onmouseover		срабатывает, когда курсор наводится на элемент или на один из его потомков
onmouseout		срабатывает, когда курсор выходит за пределы элемента
onmousedown		срабатывает в момент нажатия на кнопку мыши над элементом
onmouseup		срабатывает, когда пользователь отпускает кнопку мыши над элементом
onblur			возникает при потере элемента фокуса
onfocus			возникает при получении элементом фокуса

Обработчики событий могут быть присвоены к элементам: */
	var x = document.getElementById("demo");
	x.onclick = function() {
		document.body.innerHTML = Date();
	}
/*
Метод addEventListener() добавляет обработчик событий к элементу без перезаписи существующих обработчиков событий. Таким образом можно добавить много обработчиков событий к одному элементу.
Синтаксис:
element.addEventListener("click", myFunction, true);
"click" - тип события
myFunction - вызываемая функция
true или false - опционально. Используется, когда есть одно событие, которое обрабатывается для множества элементов DOM. По умолчанию false "всплытие" (когда событие <p> вложенного по иерархии в <div> выполнится первее). Или true "перехват" (когда событие <p> вложенного по иерархии в <div> выполнится, как и положено по иерархии, после события <div>)
*/
	element.addEventListener("click", myFunction); // используется "click" а не "onckick"!
	element.addEventListener("mouseover", myFunction);
	function myFunction() {
		alert("Привет!");
	}



// ES6 - ECMAScript 6 (ECMAScript 2015) - шестое издание спецификации js



// Переменные
	let x1 = 10;
	const x2 = 10;
/* Ключевое слово var используется для объявления переменной глобально, или локально для всей функции, независимо от области видимости блока.
Ключевое слово let объявляет переменные, ограниченные по области видимости до блока, инструкции или выражения, в которых они используются.
Переменные const (константы) видимы, как и let, только они неизменны, после объявления с каким-то значением им нельзя присвоить новое значение. */
	for (let i = 0; i < 3; i++) { // очень удачное применение let в циклах
		document.write(i);
	}



// Шаблонные строки
	let name = 'мир';
	let msg = `Привет, ${name}!`;
	document.write(msg); // Привет, мир!
/* Используются обратные кавычки (`), а не " или '. ${} - заполнитель, который может содержать любое выражение. */
	let a = 8;
	let b = 34;
	let msg = `Сумма ${a+b}`;
	document.write(msg); // Сумма 42



// Цикл for...in
/* Предназначен для итерации числовых ключей ОБЪЕКТА. Не используется для итерации массивов! */
	let example = {
		name1: 10, name2: "text", name3: 40
	};
	for (let s in example) { 
		document.write(s); // name1name2name3
	}

// Цикл for...of
/* Создает цикл итерирующий итерируемые (iterable) объекты */
	let example = ["x", "y", "z"];	// x
	for (let s of example) {		// y
		console.log);				// z
	}
/* Также применим для других итерируемых объектов, включая строки: */
	for (let x of "Мир") { 			// М
		console.log(x);				// и
	}								// р



// Функции в ES6
/* До ES6 функция определялась так: */
	function add(x, y) {
		var sum = x + y;
		console.log(sum); // 42
	}
/* В ES6 доступен новый синтаксис для написания "стрелочной" функций. Приведенный выше пример можно написать так: */
	const add = (x, y) => {
		let sum = x + y;
		console.log(sum); // 42
	}
/* Это удобно для написания простых функций с одним аргументом: */
	const greet = x => "Welcome " + x; // в этом варианте без скобок!
	console.log(greet("Tod"));
/* Если параметры не заданы, нужно добавить пару круглых скобок: */
	const m = () => "Привет, мир!";
	console.log(m());
/* Это полезный синтаксис для встраиваемых функций: */
	const x = [2, 3, 7, 8];
	x.forEach(a => {			// метод forEach массива вызовет функцию для каждого элемента
		document.write(a*2);	// 461416
	});
/* Пример стрелочной фонкции с доступными в ES6 параметрами по умолчанию: */
	const test = (a, b=10, c=20) => {
		return a+b+c;
	}
	console.log(test(5)); // 35



// Объекты в ES6
/* Инициализация переменной и свойства переменной с тем же именем: */\
	let ves = 60;
	let rost = 176;
	let gerla = {
		ves,
		rost
	}
	console.log(gerla.rost); // 176
/* ES6 позволяет использовать вычисляемые имена свойств (задаются при помощи квадратных скобок []). Это может пригодиться при создании пользовательских объектов на основе нескольких переменных. */
// пример 1:
	let prop = 'name';
	let id = '1234';
	let tel = '+375 25 123-45-67';
	let user = {[prop]: 'Антон', [`user_${id}`]: `${tel}`};
	console.log(user.name); 		// Антон
	console.log(user.user_1234);	// +375 25 123-45-67
// пример 2:
	var i = 0;
	var a = {
		['foo' + ++i]: i,
		['foo' + ++i]: i,
		['foo' + ++i]: i
	};
	console.log(a.foo1); // 1
	console.log(a.foo2); // 2
	console.log(a.foo3); // 3

// Object.assign()
/* Метод, который позволяет объединять несколько источников в одной цели для создания одного нового объекта, или для создания дубликата объекта. */
	let person = { name: 'Ivan', age: 18, sex: 'male' };	// первый источник
	let student = { name: 'Anton', age: 20, xp: '2' };		// второй источник
	let newStudent = Object.assign({}, person, student);	// создаём новый объект
	console.log(newStudent.name);	// Anton
	console.log(newStudent.age);	// 20
	console.log(newStudent.sex);	// male
	console.log(newStudent.xp);		// 2
/* Дублирование объекта, без создания ссылки (мутации) к базовому объекту: */
/* Стандартный подход создавал мутацию: */
	let person = {name:'Jack', age:18};
	let newPerson = person;
	newPerson.name = 'Bob';
	console.log(person.name);		// Bob
	console.log(newPerson.name);	// Bob
/* Object.assign() не создаёт мутацию: */
	let person = {name:'Jack', age:18};
	let newPerson = Object.assign({}, person);
	newPerson.name = 'Bob';
	console.log(person.name);		// Jack
	console.log(newPerson.name);	// Bob



// Деструктуризация в ES6
/* Синтаксис деструктурирующего присваивания позволяет извлекать значения из массива или свойства из объекта в определённые переменные. */
	let arr = ['1', '2', '3'];
	let [q, a, z] = arr;
	console.log(q); // 1
	console.log(a); // 2
	console.log(z); // 3
/* Можно деструктурировать массив, возвращенный функцией: */
	let a = () => {
		return [1, 3, 8, 15];
	};
	let [q, , , k] = a();
	console.log(q); // 1
	console.log(k); // 15
/* Синтаксис деструктуризации также упрощает назначение и смену значений: */
	let a,b,c=4,d=8;	// a = не определено, b = не определено, c = 4, d = 8
	[a,b=6]=[2];		// a = 2, b = 6, c = 4, d = 8
	[c,d]=[d,c];		// a = 2, b = 6, c = 8, d = 4
/* Синтаксис деструктуризации ОБЪЕКТА подобен синтаксису деструктуризации массива: */
	let obj = {h:100,s:true};
	let {h,s} = obj;
	console.log(h); // 100
	console.log(s); // true
/* Синтаксис назначения без объявления: */
	let a,b;
	({a,b}={a:'Привет ',b:'мир'});
	console.log(a+b); // Привет мир
/* Или так: */
	let {a,b}={a:'Привет ',b:'мир'};
	console.log(a+b); // Привет мир
/* Можно назначить объект для новых имён переменных: */
	var o={h:42,s:true};
	var {h:foo,s:bar}=o;
	// console.log(h);	// error
	console.log(foo);	// 42
	// console.log(s);	// error
	console.log(bar);	// true
/* И можно назначить значения по умолчанию для переменных, когда извлечённое из объекта значение не определено: */
	var obj={id:42,name:'Иван'};
	let {id=10,age=20}=obj;
	console.log(id);		// 42
	console.log(name);		//
	console.log(obj.name);	// Иван
	console.log(age);		// 20



// rest - параметр (остаточный параметр)
/* Пример функции, проверяющей содержит ли массив все передаваемые аргументы: */
	function containsAll(arr,...a){ // rest-параметр ...a убирает все "лишние" аргументы, передаваемые функции
		for (let b of a){
			if (arr.indexOf(b) === -1){
				return false;
			}
		}
		return true;
	}
	let x=[2,4,6,7,8];
	console.log(containsAll(x,2,4,6,7,8));	// true
	console.log(containsAll(x,4));			// true
	console.log(containsAll(x,'for'));		// false
	console.log(containsAll(x,3));			// false
	console.log(containsAll(x,24));			// false



// Оператор расширения
// в вызовах функций:
	const myFunction = (w,x,y,z) => {
		console.log(w+x+y+z);
	};
	let args = [1,2,3];
	myFunction(...args,4)	// 10
/* Пример: */
	var myBirthday = [1976,10,11,19]; // 11.11.1976, семь часов вечера
	var date = new Date(...myBirthday);
	console.log(date); // Thu Nov 11 1976 19:00:00
// расширение в литералах массива
	let newArr = ['Три', 'Четыре'];
	let arr = ['Один', 'Два', ...newArr, 'Пять'];
	console.log(arr); // Один,Два,Три,Четыре,Пять
// расширение в объектных строках
	const obj1 = {foo:'bar',x:42};
	const obj2 = {foo:'baz',y:5};
	const clonedObj = {...obj1}; // foo: "bar", x: 42
	const mergedObj = {...obj1,...obj2}; // foo: "baz", x: 42, y: 5



// КЛАССЫ
/* Объявления класса, в отличие от объявлений функции, не подняты. Попытка получить доступ к классу до объявления вызовет ReferenceError */
/* Класс использует ключевое слово class и содержит метод constructor, предназначенный для инициализации. Объявленный класс может затем использоваться для создания множества объектов при помощи ключевого слова new. */
	class Rectangle {
		constructor(height, width) {
			this.height = height;
			this.width = width;
		}
	};
	const square = new Rectangle(5, 5);
	const poster = new Rectangle(2, 3);
/* Можно определить класс при помощи выражения class, в котором он может быть назван или не назван. */
// Пример с именованным классом:
	var Square = class Rectangle {
		constructor(height, width) {
			this.height = height;
			this.width = width;
		}
	};
	const square = new Square(5, 5);
	const poster = new Square(2, 3);
// Пример с неименованным классом (тот же результат):
	var Square = class {
		constructor(height, width) {
			this.height = height;
			this.width = width;
		}
	};
	const square = new Square(5, 5);
	const poster = new Square(2, 3);

// Методы класса
/* ES6 не требует ключевого слова function для функции, присвоенной имени метода. */
/* Прототипный метод - тип классового метода, доступный для объектов класса: */
	class Rectangle {
		constructor(height, width) {
			this.height = height;
			this.width = width;
		}
		get area(){ // геттер
			return this.calcArea();
		}
		calcArea(){ // метод
			return this.height * this.width;
		}
	};
	const square = new Rectangle(5, 5);
	console.log(square.area); // 25
/* Статический метод - не может быть ваызван из экземпляра класса. Такой метод часто используют для создания служебных функций в приложении. */
	class Point {
		constructor(x,y) {
			this.x = x;
			this.y = y;
		}
		static distance(a,b){
			const dx=a.x-b.x;
			const dy=a.y-b.y;
			return Math.hypot(dx,dy);
		}
	};
	const p1 = new Point(7,2);
	const p2 = new Point(3,8);
	console.log(Point.distance(p1,p2));
/* В примере статический метод distance вызывается напрямую с использованием имени класса без объекта. */

// Наследование в классах
/* Ключевое слово extends используется при объявлении класса или классовых выражений для создания дочернего класса. Дочерний класс наследует свойства и методы родительского. */
	class Animal {
		constructor(name){
			this.name = name;
		}
		speak(){
			console.log(this.name + ' издаёт звук.');
		}
	}
	class Dog extends Animal {
		speak(){
			console.log(this.name + ' лает.');
		}
	}
	let animal = new Animal('Хорёк');
	animal.speak(); // Хорёк издаёт звук.
	let dog = new Dog('Бобик');
	dog.speak(); // Бобик лает.
/* Если в подклассе присутствует конструктор, перед использованием this надо вызвать super(). Кроме того, ключевое слово super используется для вызова родительских методов. */



// Map
/*
Объект Map можно использовать для пары ключ/значение. Ключом может быть что угодно (объекты и примитивы).
Синтаксис: new Map([iterable]) создает объект Map, где iterable - это массив или другой повторяющийся объект, чьи элементы являются массивами (каждый содержит пару ключ/значение).
- Ключи могут быть любого типа, включая функции, объекты и любые примитивы.
- Можно получить size Map (.size).
- Можно напрямую итерировать Map.
- Map удобен в случаях частого добавления/удаления пары ключ/значение.
*/
	let map = new Map([['k1','v1'],['k2','v2']]);
	console.log(map.size); // 2
/*
Методы:
set(key,value)	- добавляет конкретную пару ключ/значение в Map. Если выбранный ключ уже существует, соответствующее ему значение заменяется выбранным значением.
get(key)		- получает значение, относящееся к конкретному ключу на Map. Если нужный ключ не существует, появляется значение undefined.
has(key)		- возвращает true, если заданный ключ представлен на Map, и false, если нет.
delete(key)		- удаляет пару ключ/значение с заданным ключом из Map и возвращает true. Возвращает false, если элемент не существует.
clear()			- удаляет все пары ключ/значение с Map.
keys()			- возвращает итератор ключей на Map для каждого элемента.
values()		- возвращает итератор значений на Map для каждого элемента.
entries()		- возврашает итератор массива [key,value] на Map для каждого элемента.
*/
	let map = new Map();
	map.set('k1','v1').set('k2','v2');
	console.log(map.get('k1')); // v1
	console.log(map.has('k2')); // true
	for (let kv of map.entries())
		console.log(kv[0] + ":" + kv[1]);
/*
Map поддерживает разные типы данных: 1 и '1' - разные.
*/



// Set
/*
Объект Set можно использовать для хранения уникальных значений (повторения запрещены). Значение в Set может быть чем угодно (объекты и примитивы).
Синтаксис: new Set([iterable]) создает объект Set, где iterable - это массив или другой итерабельный объект или значение.
Свойство size показывает число отдельных значений в Set.
*/
	let set = new Set([1,2,4,59,9,4,9,1,18]);
	console.log(set.size); // 6, а не 9, т.к. повторения запрещены
/*
Методы:
add(value)		- добавляет в Set новый элемент с заданным значением.
delete(value)	- удаляет определенное значение из Set.
has(value)		- возвращает true, если заданное значение существует в Set, и false, если нет.
clear()			- очищает Set.
values()		- возвращает итератор значений в Set.
*/
	let set = new Set();
	set.add(5).add(9).add(59).add(9);
	console.log(set.has(9)); // true
	for (let v of set.values())
		console.log(v); // 5 // 9 // 59
/*
Set поддерживает разные типы данных: 1 и '1' - разные. NaN и undefined Также могут храниться в Set.
*/