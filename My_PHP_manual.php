<?	/*
СОДЕРЖАНИЕ:

	Переменные
		Переменные переменных
		Область видимости переменных
  
	Константы
		define()
  
	Операторы
		Арифметические операторы
		Инкремент и Декремент
		Операторы присвоения
		Операторы сравнения
		Логические операторы
  
	Массивы
		Числовые массивы
		Ассоциативные массивы
		Многомерные массивы
  
	Условные операторы и циклы:
		If Else
		Elseif
		While
		Do...While
		For
		Foreach
		Switch
		Break
		Continue
  
	Include & Require
 
	Функции
		function functionName()
  
  	Математические функции (встроенные)
   		abs()
     		round(), ceil(), floor()
       		rand()
	 	min(), max()
   
	Суперглобальные предопределенные переменные:
		$GLOBALS
		$_SERVER
		$_POST и $_GET
		$_REQUEST
		$_SESSION
			session_start() - запуск сессии
			session_unset() - очистка (сброс) сессии
			session_destroy() - закрытие сессии
		$_FILES
		$_ENV
		$_COOKIE
			setcookie() - создание cookie
   
	Работа с файлами
		fopen() - создание/открытие файла
		fwrite() - запись в файл
		fclose() - закрытие файла
		file() - считывание файла в массив
  
	Классы
		class className {}
		$this
		Конструктор __construct()
		Деструктор __destruct()
  
	Дата и время
		date()
		mktime()
		strtotime()
  
	Отправка сообщений
		mail()
	*/
?>



<? // Сокращенный открывающий тег тоже будет понят сервером, но это не по фен-шую.
	echo "Hello World!"; // Можно использовать одинарные или двойные кавычки
?>

<?php
// Переменные
	$name = 'John'; /* Переменная. Тип указывать не нужно, он определяется автоматисески. Имя переменной может содержать A-z, 0-9 и _. Чувствительны к регистру! Имя переменной не должно начинаться с цифры, - только с буквы или нижнего подчеркивания. */
	$age = 25;
	echo $name;
?>

<?php
// Переменные переменных
	$a = 'hello'; // Можно использовать одну переменную для определения имени другой переменной.
	$hello = 'Hi!';
	echo $$a; // Outputs 'Hi!'
?>

<?php
/*	Область видимости переменных
	Глобальная - переменная, объявленная вне функции.
	Локальная - переменная, объявленная внутри функции. Может быть доступна только внутри функции. */
	$num = 56;
	function my_func(){
		$num = 89;
		echo $num; // Outputs 89
	}
	my_func();
?>
<?php
/*	Ключнвое слово 'global' используется для доступа к глобальной переменной внутри функции. */
	$name = 'David';
	function getName() {
		global $name;
		echo $name; // Outputs 'David'
	}
	getName();
?>



<?php
/*	Константы
Синтаксис:
	define(name, value, case-insensitive);
		name - имя константы
		value - значение константы
		case-insensitive - не чувствительность к регистру. По умолчанию false.
Константы не переопределяются после их первоначального определения.*/
	define("MSG", "Hi Sololearns!");
	echo MSG; // Outputs "Hi Sololearns!"
?>
<?php
	define("MSG", "Hi Sololearns!", true);
	echo msg; // Outputs "Hi Sololearns!"
?>



<?php
// Арифметические операторы
/*
	Сложение (+), вычитание (-), умножение (*), деление (/), деление по модулю (%)
*/

// Инкремент и Декремент
/*
	$x++; post-increment
	$x--; post-decrement
	++$x; pre-increment
	--$x; pre-decrement
*/


// Операторы присвоения
/*
	Оператор	Название			Пример		Результат
	+=			сложение			x+=y		то же что и x=x+y
	-=			вычитание			x-=y		то же что и x=x-y
	*=			умножение			x*=y		то же что и x=x*y
	/=			деление				x/=y		то же что и x=x/y
	%=			дел.по мод.			x%=y		то же что и x=x%y
*/

// Операторы сравнения
/*
	Оператор	Название			Пример		Результат
	==			равно				$x == $y	TRUE если $x равно $y
	===			идентично			$x === $y	TRUE если $x равно $y и они одного типа
	!=			не равно			$x != $y	TRUE если $x не равно $y
	<>			не равно			$x <> $y	TRUE если $x не равно $y
	!==			не идентично		$x !== $y	TRUE если $x не равно $y или они не одного типа
	>			больше чем			$x > $y		TRUE если $x больше чем $y
	<			меньше чем			$x < $y		TRUE если $x меньше чем $y
	>=			больше либо равно	$x >= $y	TRUE если $x больше либо равно $y
	<=			меньше либо равно	$x <= $y	TRUE если $x меньше либо равно $y
*/

// Логические операторы
/*
	Оператор	Название			Пример		Результат
	and			И					$x and $y	TRUE если и $x и $y истинны
	or			ИЛИ					$x or $y	TRUE если либо $x либо $y истинны
	xor			Исключающее или		$x xor $y	TRUE если либо $x либо $y истинны, но не оба вместе
	&&			И					$x && $y	TRUE если и $x и $y истинны
	||			ИЛИ					$x || $y	TRUE если либо $x либо $y истинны
	!			Не					!$x			TRUE если $x не истинно
*/
?>



<?php
// Числовые массивы
	$people = array("David", "Amy", "John"); // Индекс присваивается автоматически
/* Важно! Индексом первого элемента массива является 0, а не 1! */

	$names[0] = "David"; // Вариант с присвоением индекса вручную
	$names[1] = "Amy";
	$names[2] = "John";
	echo $names[1]; // Outputs "Amy";

/* В одном массиве можно хранить значения разных типов данных*/
	$myArray[0] = "John";
	$myArray[1] = "<strong>PHP</strong>";
	$myArray[2] = 21;
	echo "$myArray[0] is $myArray[2] and knows $myArray[1]"; // Outputs "John is 21 and knows PHP"
?>

<?php
// Ассоциативные массивы
/* В них используются именованные ключи. */
	$people = array("David"=>"27", "Amy"=>"21", "John"=>"42"); // В таком варианте именного массива используются "=>" для присвоения значений ключам
	// Другой вариант записи ассоциативного массива:
	$human['David'] = "27";
	$human['Amy'] = "21";
	$human['John'] = "42";
	
	echo $human['Amy']; // Outputs 21
?>

<?php
// Многомерные массивы
/* Для двухмерного массива понадобится два индекса, чтобы выбрать элемент. Для трехмерного - три. Массивы, более трех уровней глубины сложны для управления. */
// Пример двухмерного массива, содержащего в себе три массива:
	$people = array(
		'online'=>array('David', 'Amy'),
		'offline'=>array('John', 'Rob', 'Jack'),
		'away'=>array('Arthur', 'Daniel')
	);
// Чтобы получить доступ к элементам массива $people нужно указать два индекса (строку и столбец):
	echo $people['online'][0]; // Outputs 'David'
	echo $people['away'][1]; // Outputs 'Daniel'
// Массивы в многомерных массивах могут быть как числовыми, так и ассоциативными.
?>



<?php
// Оператор If Else
/*
Синтаксис:
	if (условие) {
		код выполняемый если условие истинно;
	} else {
		код выполняемый если условие ложно;
	}
Оператор else можно не использовать, если не нужно ничего выполнять в случае, когда условие ложно.
*/
	if ($gender == 0) {
		echo "Male";
	} else {
		echo "Female";
	}
?>

<?php
// Оператор Elseif
/*
Синтаксис:
	if (условие) {
		код выполняемый если условие истинно;
	} elseif (условие) {
		код выполняемый если условие истинно;
	} else {
		код выполняемый если условие ложно;
	}
Операторов elseif может быть сколько угодно, но начинаться всё должно с оператора if.
*/
	$age = 21;
	if ($age<=13) {
		echo "Child";
	} elseif ($age>13 && $age<19) {
		echo "Teenager";
	} else {
		echo "Adult"; // Outputs "Adult"
	}
/* Фигурные скобки могут быть пропущены, если есть только одно выражение после if/elseif/else, но с ними код более читабельный */
	$age = 21;
	if ($age<=13)
		echo "Child";
	elseif ($age>13 && $age<19)
		echo "Teenager";
	else
		echo "Adult"; // Outputs "Adult"
?>

<?php
// Цикл While
/*
Синтаксис:
	while (условие is true) {
		выполняемый код;
	}
Если условие никогда не становится ложным, то выражение будет продолжать выполняться бесконечно!
*/
	$i = 1;
	while ($i < 7) {
		echo "The value is $i <br />";
		$i++;
	}
?>

<?php
// Цикл Do...While
/*
Синтаксис:
	do {
		выполняемый код;
	} while (условие is true);
Код будет выполнен как минимум один раз, независимо от истинности или ложности условия, и будет выполняться до тех пор, пока условие будет истинным.
*/
	$x = 5;
	do {
		echo "$x";
		$x++;
	} while ($x <= 7); // Outputs "567"
?>

<?php
//	Цикл For
/*
Синтаксис:
	for (init; test; increment) {
		выполняемый код;
	}
init: инициирует значение счетчика цикла
test:вычисляется при каждой операции цикла, продолжай выполнение, пока условие верно, и останавливаясь, если условие ложно
increment: увеличивает значение счетчика цикла
*/
	for ($a = 0; $a < 6; $a++) {
		echo $a; // Outputs 012345
	}
?>

<?php
//	Цикл Foreach
/*	Работает только с массивами. Проходит по каждой паре ключ/значение в массиве. */
/*	Есть два типа синтаксиса:
	foreach (array as $value) {
		выполняемый код;
	}
В таком варианте значение текущего элемента массива присваивается переменной $value, и указатель массива смещается на единицу, пока не достигнет последнего элемента массива.
*/
	$names = array("John", "David", "Amy");
	foreach ($names as $name) {
		echo "$name "; // Outputs "John David Amy "
	}
/*	Вторая форма при каждой итерации будет дополнительно присваивать текущий ключ элемента переменной $key.
	foreach (array as $key => $value) {
		выполняемый код;
	}
*/
	$names = array("John", "David", "Amy"); // Outputs	0 John
	foreach ($names as $key => $name) {		//			1 Dovid
		echo "$key $name<br />";			//			2 Amy
	}
?>

<?php
//	Оператор Switch
/*
Более элегантная альтернатива if/elseif/else.
Синтаксис:
	switch (n) {
		case value1:
			код выполняемый при n=value1;
			break;
		case value2:
			код выполняемый при n=value2;
			break;
		...
		default:
			код выполняемый при n!=values;
	}
*/
	$today = 'Tue';
	switch ($today) {
		case "Mon":
			echo "Today is Monday.";
			break;
		case "Tue":
			echo "Today is Tuesday.";
			break;
		case "Wed":
			echo "Today is Wednesday.";
			break;
		case "Thu":
			echo "Today is Thursday.";
			break;
		case "Fri":
			echo "Today is Friday.";
			break;
		case "Sat":
			echo "Today is Saturday.";
			break;
		case "Sun":
			echo "Today is Sunday.";
			break;
		default:
			echo "Invalid day.";
	} // Outputs "Today is Tuesday."
/*
Ключевое слово break используется для предотвращения перехода в следующий case. Если его не указать, то, после истинного сектора case, PHP будет выполнять все последующие, независимо от их истинности.
*/
	$day = 'Wed';
	switch ($day) {
		case "Mon":
		case "Tue":
		case "Wed":
		case "Thu":
		case "Fri":
			echo "Working day.";
			break;
		default:
			echo "Weekend!";
	} // Outputs "Working day."
/*
Выражение default используется, если не было найдено соответствие. Оно опциональное и, при необходимости, может быть опущено.
*/
?>

<?php
//	Оператор Break
	for($i=0;$i<=50;$i++) {
		echo $i;
		if ($i==5) {
			break; // выходим их цикла после вывода "5" на экран
		}
	}
/*
Оператор break заканчивает текущий for, foreach, while, do-while, или switch и продолжает выполнять программу со строки, расположенной сразу после цикла.
Во внешней части программы (т.е. не в управляющем цикле) оператор break остановит скрипт!
*/
?>

<?php
//	Оператор Continue
	for($i=0;$i<=10;$i++) {
		if ($i%2==0) {
			continue; // пропускаем четные числа
		}
		echo $i.' ';
	} // Outputs 1 3 5 7 9
/*
Оператор continue внутри структуры цикла пропускает то, что осталось от текущей итерации и переходит к следующей.
*/
?>



<html>
<!-- Include и Require
Включает содержимое одного PHP файла в другой PHP файл (по аналогии с технологией SSI).
Include - некритичное включение, когда, если включаемый файл не найден, скрипт продолжает выполняться.
Require - для важных включений, когда, если включаемый файл не найден, скрипт прекратит выполнение и выдаст ошибку. -->
	<body>
		<?php
			include 'header.php';
		?>
		<?php
			require 'login.php';
		?>
		<?php
			include 'footer.php';
		?>
	</body>
<!-- Можно использовать абсолютные или относительные пути. -->
</html>



<?php
/*	Функции - блок выражений, которые могут повторно использоваться в программе.
Синтаксис:
	function functionName() {
		выполняемый код;
	}
Имена функций могут начинаться с буквы или "_", НЕ чувствительны к регистру.
*/
	function functionName() {
		echo "Hi!"; // Outputs "Hi!"
	}
	functionName(); // вызов функции
/*
Информация может быть передана в функции через аргументы (внутри скобок), которые являются переменными. Их может быть один или много.
*/
	function myFun($num) {
		$res = $num *2;
		echo $res; // Outputs 20
	}
	myFun(10);
	
	function myFunc($num1, $num2) {
		echo $num1 + $num2; // Outputs 9
	}
	myFunc(3, 6);
/*
Для аргументов функции могут быть определены аргументы по умолчанию.
*/
	function setCounter($number=10) {
		echo "Counter is ".$number;
	}
	setCounter(45); // Counter is 45
	setCounter(); // Counter is 10
/*
Функция может возвращать одно (не множество и не массив) значение с помощью оператора return. Он останавливает выполнение функции и отправляетзначение обратно к вызывающему коду. Без return будет возвращено NULL.
*/
	function mult($x, $y) {
		$sum = $x + $y;
		return $sum;
	}
	echo mult(8, 5); // Outputs 13
?>



<?php
/*
Математические функции (встроенные)

abs()
round(), ceil(), floor()
rand()
min(), max()
*/

	abs(-20); // возвращает абсолютное число, - в данном примере вернёт 20

	round(2.50); // округление по общепринятым правилам, - в данном примере вернёт 3
	ceil(2.1); // округление в большую сторону, - в данном примере вернёт 3
	floor(2.5); // округление в меньшуб сторону, - в данном примере вернёт 2

	rand(0, 100); // генерирует случайное число в указанном диапазоне

	min(); max(); // возвращает min/max число из переданных в качестве аргументов
?>



<?php
/*
Суперглобальные предопределенные переменные в PHP
$GLOBALS, $_SERVER, $_POST, $_GET, $_REQUEST, $_SESSION, $_COOKIE, $_FILES, $_ENV
доступны из любой области видимости, из любой функции, класса или файла.
*/
?>

<?php
/*	$GLOBALS
это суперглобальная переменная PHP, которая используется для доступа к глобальным переменным из любой точки скрипта PHP (также из функций или методов).
PHP хранит все глобальные переменные в массиве под названием $GLOBALS[index]. Индекс содержит имя переменной.
В приведенном ниже примере показано, как использовать супер глобальную переменную $GLOBALS:
*/
	$x = 75; 
	$y = 25;
	function addition() { 
		$GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; 
	}
	addition(); 
	echo $z; // Outputs 100
?>

<?php
/*
	$_SERVER - массив, включает заголовки, пути и местонахождения скриптов.
*/
	echo $_SERVER['SCRIPT_NAME']; // возвращает путь к текущему скрипту
	echo $_SERVER['SCRIPT_FILENAME']; // возвращает имя абсолютного пути к текущему выполняемому скрипту
	echo $_SERVER['SCRIPT_URL']; // возвращает url текущей страницы
	echo $_SERVER['HTTP_HOST']; // возвращает заголовок host'а из текущего запроса
	echo $_SERVER['HTTP_ACCEPT']; // возвращает заголовок Accept из текущего запроса
	echo $_SERVER['HTTP_ACCEPT_CHARSET']; // возвращает заголовок Accept_Charset из текущего запроса (например, utf-8, ISO-8859-1)
	echo $_SERVER['HTTP_REFERER']; // возвращает полный URL-адрес страницы, с которой была вызвана текущая страница
	echo $_SERVER['HTTP_USER_AGENT']; // возвращает строку, описывающую браузер, отправивший запрос
	echo $_SERVER['HTTPS']; // запрашивается ли скрипт по безопасному протоколу HTTP?
	echo $_SERVER['PHP_SELF']; // возвращает имя файла текущего выполняемого скрипта
	echo $_SERVER['PATH_TRANSLATED']; // возвращает путь файловой системы к текущему скрипту
	echo $_SERVER['SERVER_ADDR']; // возвращает IP адрес host сервера
	echo $_SERVER['SERVER_NAME']; // возвращает имя host сервера
	echo $_SERVER['SERVER_PORT']; // возвращает используемый на сервере порт для коммуникации (такой как 80)
	echo $_SERVER['SERVER_SOFTWARE']; // возвращает строку идентификации сервера (например, Apache / 2.2.24)
	echo $_SERVER['SERVER_PROTOCOL']; // возвращает имя и версию информационного протокола (например, HTTP / 1.1)
	echo $_SERVER['SERVER_ADMIN']; /* возвращает значение, данное директиве SERVER_ADMIN в файле конфигурации веб-сервера (если ваш сценарий выполняется на виртуальном хосте, это будет значение, определенное для этого виртуального хоста) (например, somebody@site.com) */
	echo $_SERVER['SERVER_SIGNATURE']; // возвращает версию сервера и имя виртуального хоста, которые добавляются на сгенерированные сервером страницы
	echo $_SERVER['GATEWAY_INTERFACE']; // возвращает версию Common Gateway Interface (CGI), которую использует сервер
	echo $_SERVER['REMOTE_ADDR']; // возвращает IP адрес, с которого пользователь просматривает текущую страницу
	echo $_SERVER['REMOTE_HOST']; // возвращает имя host'а, с которого пользователь просматривает текущую страницу
	echo $_SERVER['REMOTE_PORT']; // возвращает используемый пользователем порт для коммуникации с веб-сервером
	echo $_SERVER['REQUEST_METHOD']; // возвращает метод запроса, используемый для доступа к странице (например, POST)
	echo $_SERVER['REQUEST_TIME']; // возвращает метку времени начала запроса (например, 1377687496)
	echo $_SERVER['QUERY_STRING']; // возвращает строку запроса, если доступ к странице осуществляется через строку запроса
	
?>

<!-- пример использования для создания динамически меняющегося абсолютного пути к изображениям (не привязанного к определенному хосту) -->
<?php // создаем файл "config.php", содержащий путь к изображениям
	$host = $_SERVER['HTTP_HOST'];
	$image_path = $host.'/images/';
?>
<?php // используем файл "config.php" в скриптах
	require 'config.php';
	echo '<img src="'.$image_path.'header.png" />';
?>



<?php
/*	$_POST и $_GET - собирают информацию, вводимую пользователями в формы.

Метод POST предпочтительнее защищенностью передаваемой информации (она невидима другим, встроена в теле HTTP запроса), нет лимита по количеству отправляемой информации, поддерживает передачу составных данных.

Метод GET видимый (имена и значения переменных отображаются в URL), имеет лимит (около 2000 символов) по кол-ву передаваемой информации. Его плюс - в отличие от POST, он может сделать закладку страницы. GET нельзя использовать для передачи паролей и другой важной информации.

При использовании POST или GET важно проверять данные формы фильтрациями и обработками, чтобы не хакнули.
*/
?>
<html>
	<body>
		<form action="first.php" method="post">
		<!-- action указывает в какой файл отправляем инфу, method - каким методом -->
			<p>Name: <input type="text" name="name" /></p>
			<p>Age: <input type="text" name="age" /></p>
			<p><input type="submit" name="submit" value="Submit" /></p>
			<!-- имена (name) будут ключами в парах  -->
		</form>
	</body>
</html>
<!-- С помощью массива $_POST мы получаем доступ к размещенной в форме информации в файле first.php: -->
<html>
	<body>
		Welcome <?php echo $_POST["name"]; ?><br />
		Your age: <?php echo $_POST["age"]; ?>
		<!-- Массив $_POST и $_GET хранит пары ключ/значение. Ключи - имена (names) элементов формы, значения - введенные пользователем данные. -->
	</body>
</html>

<html>
	<body>
		<form action="actionGet.php" method="get">
			<p>Name: <input type="text" name="name" /></p>
			<p>Age: <input type="text" name="age" /></p>
			<p><input type="submit" name="submit" value="Submit" /></p>
		</form>
	</body>
</html>
<?php // Файл actionGet.php
	echo "Hi ".$_GET["name"].".";
	echo "You are ".$_GET["age"]." years old.";
?>

<?php
/*	$_REQUEST
используется для сбора данных после отправки формы HTML.

В примере ниже -  форма с полем ввода и кнопкой отправки. Когда пользователь отправляет данные, нажимая «Отправить», данные формы отправляются в файл, указанный в action. Затем мы можем использовать суперглобальную переменную $_REQUEST для сбора значения поля ввода:
*/
?>
<html>
<body>
<form method="post" action="test.php">
  Name: <input type="text" name="fname">
  <input type="submit">
</form>
<?php
if ($_SERVER["REQUEST_METHOD"] == "POST") { // сбор значений поля ввода
    $name = $_REQUEST['fname'];
    if (empty($name)) {
        echo "Name is empty";
    } else {
        echo $name;
    }
}
?>
</body>
</html>

<?php
/*	$_SESSION
Используя сессии можно хранить информацию в переменных, чтобы использовать ее на нескольких страницах. По умолчанию переменные сессии существуют пока пользователь не закроет браузер. */
	session_start(); // Запуск сессии. Эта функция должна быть первой вещью в документе, до любых HTML тегов!
	
	$_SESSION['color'] = "red";
	$_SESSION['name'] = "John";
// Теперь переменные сессии color и name доступны на всех страницах на протяжении всей сессии:
?>	
<?php
	session_start(); // Запуск сессии
?>
<!DOCTYPE html>
<html>
	<body>
	<?php
		echo "Your name is ".$_SESSION['name']; //Outputs "Your name is John"
	?>
	</body>
</html>
<!--
Переменные сессии могут быть убраны вручную с помощью session_unset()
Закрыть сессию можно с помощью session_destroy()
-->

<?php
	// Для каждого загруженного файла массив $_FILES содержит массив, со следующими данными:
$_FILES['userfile']['name'] // исходное имя файла, такое, каким его видел пользователь, выбирая файл;
$_FILES['userfile']['type'] // mime/type файла, к примеру, может быть image/gif; это поле полезно сохранить, если Вы хотите предоставлять интерфейс для скачивания загруженных файлов;
$_FILES['userfile']['size'] // размер загруженного файла;
$_FILES['userfile']['tmp_name'] // полный путь к временному файлу на диске;
$_FILES['userfile']['error'] // Начиная с версии 4.2.0, содержит код ошибки, который равен 0, если операция прошла успешно.
?>

<?php
	/*	$_ENV — Переменная окружения
	Ассоциативный массив (array) значений, переданных скрипту через переменные окружения.
	Эти значения импортируются в глобальное пространство имен PHP из системных переменных окружения, в котором запущен парсер PHP. Большинство значений передаётся из командной оболочки, под которой запущен PHP, и в разных системах, вероятно, используются разные типы оболочек поэтому окончальный список невозможно представить. Нужно изучить документацию к используемой командной оболочке для получения списка переменных окружения.
	*/
	// Пример (скрипт запустил Иван):
	echo 'Мое имя пользователя: ' .$_ENV["USER"] . '!'; // Outputs "Мое имя пользователя: Иван!"
?>

<?php
/*	Cookies часто используются для идентификации пользователя. С помощью PHP можно создавать и получать значения cookie.
	Для создания cookie используется функция setcookie()
	Синтаксис:
	setcookie(name, value, expire, path, domain, secure, httponly);
		name - определяет имя cookie. Единственный обязательный параметр, остальные - опциональные.
		value - определяет значение cookie.
		expire - время (в секундах) окончания действия cookie. Значение time()+86400*30 установит, чтобы cookie истекали по по прошествии 30 дней. Если этот параметр опущен, или установлен на 0, то cookie истекает по окончании сессии (при закрытии браузера). 	По умолчанию значение равно 0.
		path - определяет путь cookie на сервере. Если значение установлено "/", то cookie будут доступны в пределах всей области. Если установлено "/php/", то cookie будут доступны только внутри php директории и во всех под-директориях. Значением по умолчанию является текущая директория, в которой установлено cookie.
		domain - определяет имя домена cookie. Чтобы сделать cookie доступным на всех поддоменах example.com, нужно установить домен на "example.com".
		secure - определяет, передается ли cookie по защищенному HTTPS соединению. TRUE означает, что cookie будет установлено, только если существует защищенное соединение. Значением по умолчанию является FALSE.
		httponly - если установлено на TRUE то cookie будут доступны только по HTTP протоколу (не будут доступны для скриптовых языков). Использование httponly помогает уменьшить риск кражи личных данных. Значением по умолчанию является FALSE.
	Функция setcookie() должна быть до тега <html>.
	Cookie кодируются при отправке и декодируются при получении, но, тем не менее, нельзя хранить важную информацию в cookie!
*/
//	Пример создает cookie "user" со значением "John", истекает через 30 дней и доступен на всем сайте. Затем мы получаем занчение cookie "user" используя $_COOKIE. Функция isset() использована для проверки, установлено ли cookie.
$value = "John";
setcookie("user", $value, time() + (86400 * 30), '/');

if(isset($_COOKIE['user'])) {
	echo "Value is: ". $_COOKIE['user'];	// Outputs "Value is: John"
}
?>



<?php
//	Работа с файлами
/*	fopen() создает или открывает файл. Если используется fopen() с несуществующим файлом, то файл будет создан и открыт с параметром записи (w) или добавления (a).
	Модификации для открытия файла:
	r - открывает файл только для чтения.
	w - открывает файл только для записи. Удаляет содержимое файла, или создает новый файл, если он до этого не существовал.
	a - открывает файл только для записи. При добавлении в файл с помощью режима 'a', указатель файла установлен в конец файла, что гарантирует, что вся новая информация будет добавлена в конец файла.
	x - создает новый файл только для записи.
	r+ - открывает файл для чтения/записи.
	w+ - открывает файл для чтения/записи. Удаляет содержимое файла, или создает новый файл, если он до этого не существовал.
	a+ - открывает файл для чтения/записи. Создает новый файл, если он до этого не существовал.
	x+ - создает новый файл для чтения/записи.
Пример создает новый файл "file.txt", в той же директории, где хранится php код:
*/
$myfile = fopen("file.txt", "w");
?>

<?php
/*	fwrite() записывает в файл. Первый параметр - файл для записи, втророй - строка, которую необходимо записать.
Пример записывает пару имен в новый файл "names.txt" (символ \n используется для записи новых строк):
*/
$myfile = fopen("names.txt", "w");

$txt = "John\n";
fwrite($myfile, $txt);
$txt = "David\n";
fwrite($myfile, $txt);

fclose($myfile);
/*	fclose() закрывает открытый файл и возвращает TRUE при успехе, или FALSE при ошибке.
*/

/*
Пример добавления к файлу (режим 'a' - инфа добавится в конец файла):
*/
$myfile = "test.txt";
$fh = fopen($myfile, 'a');
fwrite($fh, "Some text");
fclose($fh);
?>

<?php
// Пример формы, которая добавляет заполненную информацию в файл.
if(isset($_POST['text'])) { // Функция isset() определит, была ли отправлена форма и содержит ли текст значение.
	$name = $_POPST['text'];
	$handle = fopen('names.txt', 'a');
	fwrite($handle, $name."\n");
	fclose($handle);
}
?>
<form method="post"> <!-- Атрибут action не определяем, так что форма будет отправлена сама себе. -->
	Name: <input type="text" name="text" />
	<input type="submit" name="submit" />
</form>

<?php
/*	file() считывает весь файл в массив. Каждый элемент массива соответствует строке файла.
Пример выводит имена из файла "names.txt", разделенные запятыми:
*/
$read = file('names.txt');
foreach ($read as $line) { // используем foreach, т.к. переменная $read - массив.
	echo $line . ", ";
}
// И вариант того же, только без запятой после последнего имени:
$read = file('names.txt');
$count = count($read); // функция count получает кол-во элементов массива $read.
$i = 1;
foreach ($read as $line) {
	echo $line;
	if($i < $count) { // запятая перестанет выводиться и цикл закончится, когда $i станет равен кол-ву элементов массива $read.
		echo ', ';
	}
	$i++;
}
?>



<?php
//	Классы PHP
/*	Определение класса начинается с ключевого слова class, за которым следует название класса (начинается с _ или буквы, за которым слкедует любое кол-во букв, чисел или подчеркиваний).
	В фигурных скобках записываются свойства и методы, принадлежащие классу.
	Пример:
*/
class Person {
	public $age; // свойство
	public function speak() { // метод
		echo "Hi!";
	}
}
/*	Для создания (инстанцирования) объекта класса используется ключевое слово new:
*/
$bob = new Person();
/*	Для получения доступа к свойствам и методам класса используется конструкция "->":
*/
echo $bob->age;
?>
<?php
//	Пример:
class Person {
	public $age;
	public function speak() {
		echo "Hi!";
	}
}
$p1 = new Person(); // инстанцирование нового объекта класса
$p1->age = 23; // для присвоения значения свойству используется оператор присвоения
echo $p1->age; // Outputs 23
$p1->speak(); // Outputs "Hi!"
?>

<?php
//	$this - псевдопеременная, ссылающаяся на вызывающий объект. Позволяет объектам иметь свои свойства, отличные от установленных в классе.
// Пример:
class Dog {
	public $legs=4;
	public function display() {
		echo $this->legs;
	}
}
$d1 = new Dog();
$d1->display(); // Outputs 4

$d2 = new Dog();
$d2->legs = 2;
$d2->display(); // Outputs 2
?>



<?php
/*	Функция date() используется для форматирования даты и/или времени.
	Синтаксис:
		date(format, timestamp);
			format - обязательный параметр. Задает формат метки времени.
			timestamp - необязательный параметр. Указывает метку времени. По умолчанию используется текущая дата и время.
	Параметр format функции date () указывает, как форматировать дату (или время).
	Вот некоторые символы, которые обычно используются для дат:
	d - представляет день месяца (с 01 по 31)
	m - представляет месяц (от 01 до 12)
	Y - представляет год (из четырех цифр)
	l (нижний регистр 'L') - представляет день недели
	Другие символы, такие как «/», «.» или «-», также могут быть вставлены между символами для добавления дополнительного форматирования.
	Пример ниже форматирует сегодняшнюю дату тремя различными способами:
*/
echo "Today is " . date("Y/m/d") . "<br>";
echo "Today is " . date("Y.m.d") . "<br>";
echo "Today is " . date("Y-m-d") . "<br>";
echo "Today is " . date("l");
?>
<html>
	<body>
<!-- Используйте функцию date() для автоматического обновления года авторского права на вашем сайте: -->
	&copy; 2010-<?php echo date("Y");?>
	</body>
</html>
<?php
/*	Символы, используемые для времени:
	H - 24-часовой формат часов (с 00 до 23)
	h - 12-часовой формат часов (01-12)
	i - минуты (с 00 до 59)
	s - секунды (00 до 59)
	a - (am / pm)
	date_default_timezone_set(Time zone ID) - устанавливает значение часового пояса (при его отсутствии выводится время/дата сервера!)
	Пример ниже выводит текущее время в указанном формате:
*/
date_default_timezone_set("Europe/Minsk");
echo "The time is " . date("H:i:s")."<br>"; // Outputs "The time is 17:46:55"
echo "The time is " . date("h:i:sa"); // Outputs "The time is 05:46:55pm"
?>
<?php
/*	Указание даты с помощью mktime()
	Синтаксис: mktime(hour,minute,second,month,day,year)
*/
$d=mktime(11, 14, 54, 8, 12, 2014);
echo "Created date is " . date("Y-m-d h:i:sa", $d); // Outputs "Created date is 2014-08-12 11:14:54am"
?>
<?php
/*	Указание даты с помощью strtotime()
	Функция strtotime()используется для преобразования удобочитаемой строки во время Unix.
	Синтаксис: strtotime(time,now)
*/
//	Примеры:
$d=strtotime("10:30pm April 15 2014");
echo "Created date is " . date("Y-m-d h:i:sa", $d) . "<br>";

$d=strtotime("tomorrow");
echo date("Y-m-d h:i:sa", $d) . "<br>";

$d=strtotime("next Saturday");
echo date("Y-m-d h:i:sa", $d) . "<br>";

$d=strtotime("+3 Months");
echo date("Y-m-d h:i:sa", $d) . "<br>";

//	Пример, выводит даты следующих шести суббот:
$startdate = strtotime("Saturday");
$enddate = strtotime("+6 weeks", $startdate);

while ($startdate < $enddate) {
  echo date("M d", $startdate) . "<br>";
  $startdate = strtotime("+1 week", $startdate);
}
?>



<?php
/*	Функция mail() используется для автоматической отправки сообщений
	Синтаксис:
		mail(to, subject, message, headers);
			to - получатель сообщения.
			subject - тема сообщения.
			message - содержание сообщения.
			headers - шапки (MIME, Content-type, From, Cc, Bcc).
*/
$to = "1234578@test.com";
$subject = "Привет от Василия Пупкина!";
$message = "Третьим будешь?";
$headers = "Content-type: text/plain; charset = utf-8";
$send = mail($to, $subject, $message, $headers);
?>
